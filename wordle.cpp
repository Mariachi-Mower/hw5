// For debugging
#include <iostream>
// For std::remove
#include <algorithm> 
#include <map>
#include <set>
#include "wordle.h"
#include "dict-eng.h"
using namespace std;


// Add prototypes of helper functions here


// Definition of primary wordle function
std::set<std::string> wordle(
    const std::string& in,
    const std::string& floating,
    const std::set<std::string>& dict)
{

    std::set<std::string> final = {};//final set

		if(in.size() == 0){
			return final;
		}

		std::string testChars = floating;
		testChars += '*';

		unsigned int spaces = 0;
		for(unsigned int x = 0; x < in.size(); x++){
			//spaces will tell you the max number of spaces that can exist.
			if(in[x] == '-'){
				spaces++;
			}
		}
		spaces -= floating.size();
		//spaces holds the max number of blank characters that an anagram can hold.

		anagrams("", 0, final, dict, in, testChars, floating, spaces);
		
    return final;
}

void anagrams(std::string current, int index, std::set<std::string>& final, const std::set<std::string>& dict, const std::string& in, const std::string& testChars, const std::string floating, unsigned int spaces){
	//this helper function generates all strings containing all known chars and floating chars.
	//a second helper function is called on these produced strings to guess the remaining letters.

	if(current.size() == in.size()){
		//base case
		//once a full string is formed, checks validity of string.
		unsigned int spaceCount = 0;
		for(unsigned int i = 0; i < current.size(); i++){
			//this loop counts the number of empty spaces in the produced string.
			if(current[i] == '*'){
				spaceCount++;
			}
		}
		if(spaceCount != spaces){
			//if the amount of spaces in the string is different than what is allowed,
			//returns and doesn't call second helper.
			return;
		}

		//make a temp string copy of the current anagram
		//that you delete from until every floating char AND
		//green letter is represented at least once.
		std::string copy = current;


		unsigned int fCount = 0;
		for(unsigned int x = 0; x < floating.size(); x++){
			//this loop checks if every char in the floating string is present
			size_t found = copy.find(floating[x]);
			if(found != std::string::npos){
				//if it is, then deletes from the copy and continues to check the remaining floating chars.
				copy.erase(found, 1);
				fCount++;
			}
		}

		if(fCount == floating.size()){
			//if at has all the floating character's then it is a possible string to check.
			helper("", 0, final, dict, current);
		}
		return;
	}
	else if(in[index] != '-'){
	//it not at a full string and the char at the index is a known char,
	//then adds that known char to the current string and continues adding by recursing.
		current += in[index];
		anagrams(current, index + 1, final, dict, in, testChars, floating, spaces);
	}
	else{
		//if not yet at a complete string and the char at the index is a '-'
		//then it adds either a floating char or the '*' to indicate a blank space.
		for(unsigned int x = 0; x < testChars.size(); x++){
			//for all of the filler chars, floating + size of in as '*'
			std::string temp = current;
			temp += testChars[x];
			anagrams(temp, index + 1, final, dict, in, testChars, floating, spaces);
		}
	}
}


void helper(std::string current, int index, std::set<std::string>& final, const std::set<std::string>& dict, const std::string& in){
	//this helper function operates on all the strings generated by anagrams.
	//it tries every letter in the alphabet on space ('*') chars.
	if(current.size() == in.size()){
		//base case.
		//once a full string has been created, checks that it is a valid word.
		if(dict.find(current) != dict.end()){
			//if the word is valid, then insert it into the final set.
			final.insert(current);
		}
		return;
	}
	else if(in[index] != '*'){
		//it not at a full string and the char at the index is a known char,
		//then adds that known char to the current string and continues adding by recursing.
		current += in[index];
		helper(current, index + 1, final, dict, in);
	}
	else{//in[index] == '*'
	//if not at a full string and the char at the index is a space char,
	//then it recursively tries every letter in the alphabet
		for(int x = 0; x < 26; x++){
			std::string temp = current;
			temp += (x + 97);
			helper(temp, index + 1, final, dict, in);
		}
	}
}